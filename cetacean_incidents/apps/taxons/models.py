from django.db import models

from cetacean_incidents.apps.delete_guard import guard_deletes

class TaxonManager(models.Manager):

    def descendants(self, taxon):
        'Return a tuple of all taxa that descend from the given taxon (not including the given taxon)'
        
        # how much does order matter ? This is a depth-first traversal right
        # now.
        children = taxon.subtaxa.all()
        result = []
        for child in children:
            result.append(child)
            result += self.descendants(child)

        return tuple(result)

    def descendants_ids(self, taxon):
        'Return a tuple of the ids of all taxa that descend from the given taxon (not including the given taxon)'
        
        # how much does order matter ? This is a depth-first traversal right
        # now.
        children = taxon.subtaxa.all()
        result = []
        for child in children:
            result.append(child.id)
            result += self.descendants(child)

        return tuple(result)

    def with_descendants(self, taxon):
        'Return a tuple of all taxa that descend from the given taxon (including the given taxon)'

        return (taxon,) + self.descendants(taxon)

class Taxon(models.Model):
    '''\
    A taxon could be a genus, a species, a phylum, a superspecies, etc. the
    different entries in this table form a tree (via the supertaxon
    self-reference).

    Whether it's a genus or a species (or a subspecies or a infragenus, etc.) is
    somewhat arbitrary, although a standardized system is the goal of the ICZN.
    For our purposes, we have taxa with very well-accepted ranks. Unranked
    taxa are currently not supported (note that ranks are often used for
    sorting, so you would need at least some autogenerated rank based on the
    Taxon tree), which is more complicated than you think.
    
    '''
    
    tsn = models.IntegerField(
        #unique=True,
        blank=True,
        null=True,
        verbose_name= 'ITIS TSN',
        help_text= "An ITIS (Integrated Taxonomic Information System) TSN (Taxonomic Serial Number)",
    )

    # The ranks are numbered so that negative ones are part of a binomial name,
    # whereas positive ones are larger groupings.

    MAIN_RANKS = (
        (-1.0, 'species'),
        (0.0, 'genus'),
        (1.0, 'family'),
        (2.0, 'order'),
    )
    # generate the super-, sub-, and infra-, ranks
    RANK_CHOICES = ()
    for rank in MAIN_RANKS:
        RANK_CHOICES += (
            (rank[0] - 0.4, 'infra' + rank[1]),
            (rank[0] - 0.2, 'sub' + rank[1]),
            rank,
            (rank[0] + 0.4, 'super' + rank[1]),
        )
    
    '''A map from ITIS rank names to our numeric ranks'''
    ITIS_RANKS = {
        'Kingdom':    6.0,
        'Subkingdom': 5.8,

        'Division':    5.0,
        'Subdivision': 4.8,

        'Phylum':    4.0,
        'Subphylum': 3.8,

        'Superclass': 3.4,
        'Class':      3.0,
        'Subclass':   2.8,
        'Infraclass': 2.6,

        'Superorder': 2.4,
        'Order':      2.0,
        'Suborder':   1.8,
        'Infraorder': 1.6,

        'Superfamily': 1.4,
        'Family':      1.0,
        'Subfamily':   0.8,
        #'Infrafamily', 0.6,
        
        #'Supertribe': .054,
        'Tribe':      .050,
        'Subtribe':   .048,
        #'Infratribe': .046,

        #'Supergenus':  0.4,
        'Genus':       0.0,
        'Subgenus':   -0.2,
        #'Infragenus': -0.4,

        #'Supersection': -0.46,
        'Section':      -0.50,
        'Subsection':   -0.52,
        #'Infrasection': -0.54,

        #'Superspecies': -0.6,
        'Species':      -1.0,
        'Subspecies':   -1.2,

        'Variety':    -2.0,
        'Subvariety': -2.2,

        'Forma':    -3.0,
        'Subforma': -3.2,
    }
    
    name = models.CharField(
        max_length= 255,
        help_text= 'The scientific name for this taxon (i.e. the one in Latin). Genuses and larger groups should be capitalized.',
        verbose_name= 'scientific name',
    )
    common_names = models.CharField(
        max_length = 255,
        blank= True,
        help_text= "a comma-delimited list of common English name(s) for this taxon (e.g. \"humpback whale\" or \"dolphins, porpises\"). _Very_ useful in helping the user find the one they're looking for.",
    )
    @property
    def common_names_list(self):
        return map(lambda s: s.strip(), self.common_names.split(','))
        
    supertaxon = models.ForeignKey(
        'self',
        null= True,
        blank= True,
        # TODO should be subtaxa!
        related_name='subtaxa',
        help_text="The smallest taxon that contains this one. A reference to another entry in this table; null for root-taxa.",
    )

    '''\
    A 'rank' is how specific or general this taxon is. it's a number for use in
    sorting, and a 'real' so that new ranks can always be added later. The
    mapping from a rank's name (like 'phylum', or 'subspecies') to it's number
    is:

        -1.0: species
        0.0: genus
        1.0: family
        2.0: order
        
    For prefixes 'infra-', 'sub-', and 'super-' the ranks are changed by -0.4,
    -0.2, and +0.4, respectively. Thus a superspecies has rank -0.6 (-1.0 +
    0.4). This is handy for displaying taxa, since ones below genus (i.e. ones
    with negative rank) should include all their supertaxa before them. For
    display genuses and above, simply use something like 'Order Oodonti'.
    '''
    rank = models.FloatField(choices=RANK_CHOICES)

    def _get_ancestors(self):
        if self.supertaxon is None:
            return []
        return self.supertaxon.ancestors + [self.supertaxon]
    'a list of ancestor Taxa, starting at a root'
    ancestors = property(_get_ancestors)

    def is_binomial(self):
        if not self.rank is None:
            return self.rank < 0
        # go up ancestors until a ranked one is found, if it's 0 or below, this
        # is a binomial taxon
        t = self
        while not t.rank:
            if not t.supertaxon:
                return False
            t = t.supertaxon
        if t.rank <= 0:
            return True

    # TODO cycle detection!

    objects = TaxonManager()
    def descendants(self):
        return Taxon.objects.descendants(self)
    def with_descendants(self):
        return Taxon.objects.with_descendants(self)

    class Meta:
        ordering = ['-rank', 'name']
        #order_with_respect_to = 'supertaxon'
        verbose_name = 'taxon'
        verbose_name_plural = 'taxa'

    @models.permalink
    def get_absolute_url(self):
        return ('taxon_detail', [str(self.id)]) 

    def scientific_name(self):
        '''\
        Returns just the name for taxa with rank of genus or above. For those below, returns the "G. species" style.
        '''

        if self.is_binomial() and self.supertaxon:
            # go up the taxon tree looking for a taxon with rank 0. if we find
            # one, print out it's initial, plus the names of each taxon we found
            # on the way.
            nomens = self.name
            t = self.supertaxon
            while t.rank < 0:
                nomens = t.name + ' ' + nomens
                if not t.supertaxon:
                    break
                t = t.supertaxon
            if t.rank == 0:
                return u'%s. %s' % (t.name[0], nomens)
        return self.name

    def __unicode__(self):
        return u'%s %s' % (self.name, self.get_rank_display())

guard_deletes(Taxon, Taxon, 'supertaxon')

